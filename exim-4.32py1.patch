diff -urN /usr/src/builds/exim-4.32/doc/OptionLists.txt /usr/src/builds/exim-4.32py1/doc/OptionLists.txt
--- /usr/src/builds/exim-4.32/doc/OptionLists.txt	2004-04-15 09:27:02.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/doc/OptionLists.txt	2004-04-26 00:48:00.000000000 +0100
@@ -336,6 +336,8 @@
 percent_hack_domains                 domain list     unset         main
 perl_at_start                        boolean         false         main              2.10
 perl_startup                         string          unset         main              2.10
+python_at_start                      boolean         false         main              4.30
+python_startup                       string          unset         main              4.30
 pgsql_servers                        string list     unset         main              3.14
 pid_file_path                        string          ++            main
 pipe_as_creator                      boolean         false         pipe
diff -urN /usr/src/builds/exim-4.32/docs.css /usr/src/builds/exim-4.32py1/docs.css
--- /usr/src/builds/exim-4.32/docs.css	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/docs.css	2004-04-26 00:53:34.000000000 +0100
@@ -0,0 +1,41 @@
+h1 { font-size: 1.3em; text-decoration: underline; }
+h2 { font-size: 1.1em; text-decoration: underline; }
+h3 { font-size: 1.0em; text-decoration: underline; font-weight: bold; }
+h4 { font-size: 1.0em; text-decoration: none; color: green; }
+
+h2 { margin-top: 3.5em; }
+h3 { margin-top: 2.5em; }
+
+code { color: #7f0000; }
+code:before { content: open-quote; }
+code:after  { content: close-quote; }
+
+kbd {
+    display: block;
+    margin: 1em 1em 2.5em 1em;
+    padding: 1ex;
+    background: #eaeaea;
+    color: #007f00;
+}
+
+div#frontal {
+    text-align: center;
+    margin: 6em auto;
+    width: 50%;
+}
+
+div.section {
+    margin: 1em 3em;
+}
+
+ul li {
+    margin-bottom: 1em;
+}
+
+thead tr, thead th {
+    background-color: #efffef;
+}
+
+td, th {
+    text-align: left;
+}
diff -urN /usr/src/builds/exim-4.32/exim-python.html /usr/src/builds/exim-4.32py1/exim-python.html
--- /usr/src/builds/exim-4.32/exim-python.html	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/exim-python.html	2004-04-26 00:50:21.000000000 +0100
@@ -0,0 +1,632 @@
+<html>
+
+<head>
+<title>Exim-Python Extension</title>
+<link rel="stylesheet" href="docs.css" />
+</head>
+
+<body>
+
+
+<div id="frontal">
+
+<h1>The Exim-Python Extension</h1>
+
+<p>
+<strong>Release py1</strong><br />
+25th April, 2004
+</p>
+
+<p>
+<strong>&copy; 2004 David Wilson
+&lt;<a href="mailto:dw@botanicus.net">dw@botanicus.net</a>&gt;
+</strong>
+</p>
+
+<p>
+All rights reserved except those specifically granted under the accompanying
+license. Please see the file <code>LICENSE</code> from the source distribution.
+</p>
+
+</div>
+
+
+
+
+<h2>Contents</h2>
+
+<ol>
+<li><a href="#what">What is 'Exim-Python'?</a></li>
+<li><a href="#why">Why might I need the extension?</a></li>
+<li><a href="#install">How do I install the extension?</a></li>
+<li><a href="#usage">How do I use the extension?</a></li>
+<li><a href="#notes">Things you should know before use.</a></li>
+<li><a href="#examples">Usage examples.</a></li>
+<li><a href="#changes">Changes between versions.</a></li>
+<li><a href="#future">Future considerations.</a></li>
+</ol>
+
+
+
+
+<a name="what"></a>
+<h2>What is 'Exim-Python'?</h2>
+
+
+<div class="section">
+
+    <h3>Exim</h3>
+
+    <p>
+    Exim is a message transfer agent (MTA) developed at the University of
+    Cambridge for use on Unix systems connected to the Internet. There is a
+    great deal of flexibility in the way mail can be routed, and there are
+    extensive facilities for checking incoming mail.
+    </p>
+
+    <p>
+    <a href="http://www.exim.org/">http://www.exim.org/</a>
+    </p>
+
+
+    <h3>Python</h3>
+
+    <p>
+    Python is an interpreted, interactive, object-oriented programming
+    language. It is often compared to Tcl, Perl, Scheme or Java. Python
+    combines remarkable power with very clear syntax. It has modules, classes,
+    exceptions, very high level dynamic data types, and dynamic typing. There
+    are interfaces to many system calls and libraries.
+    </p>
+
+    <p>
+    <a href="http://www.python.org/">http://www.python.org/</a>
+    </p>
+
+
+    <h3>Exim-Python</h3>
+
+    <p>
+    Exim-Python is the name for an extension to Exim which adds the ability to
+    execute compiled Python functions and methods from within Exim
+    configuration file string expansions. Since Exim uses string expansions
+    heavily throughout it's operation, this feature allows powerful added
+    control to an already very flexible mail server.
+    </p>
+
+    <p>
+    <a href="http://botanicus.net/dw/">http://botanicus.net/dw/</a>
+    </p>
+
+</div>
+
+
+
+
+<a name="why"></a>
+<h2>Why might I need the extension?</h2>
+
+<div class="section">
+    <p>
+    Exim alone is an extremely powerful mail server, approaching as feature
+    complete as one can expect from any mail server software. It is also fairly
+    easy to extend Exim using native code, but to experiment with new feature
+    implementation like this takes a lot of time.
+    </p>
+
+    <p>
+    This extension allows you to prototype a new feature for Exim quickly and
+    easily. To say it is useful only as a prototyping tool would be incorrect,
+    indeed the performance of the extension and the code running beneath it
+    should suffice for all but the highest volume mail servers.
+    </p>
+
+    <p>
+    Other potential uses of the extension include data source abstraction, for
+    example, using the Python DB-API, you can make your Exim installation
+    database-independant by calling a layer of functions that perform lookups
+    using DB-API compatible interfaces rather than directly themselves.
+    </p>
+
+    <p>
+    If you have questions regarding the usage or behaviour of this extension,
+    please contact the author at the address at the top of this document.
+    </p>
+</div>
+
+
+<a name="install"></a>
+<h2>How do I install the extension?</h2>
+
+<div class="section">
+    <h3>Prerequisites</h3>
+
+    <p>
+    You must be using a version of Python that supports the <em>boolean
+    protocol</em>. This means that a minimum version of <strong>Python
+    2.2.1</strong> is required for operation of the extension.
+    </p>
+
+
+    <p>
+    The extension is distributed in two versions - a <em>patch</em> and a
+    <em>pre-patched tarball</em>. It is recommended that you use the
+    pre-patched tarball unless you need to further extend Exim with other third
+    party patches.
+    </p>
+
+    <p>
+    <strong>Note</strong>: the pre-patched tarball also includes the latest
+    version of the <em>exiscan-acl</em> patch, available from
+    <a href="http://duncanthrax.net/exiscan-acl/"
+    >http://duncanthrax.net/exiscan-acl/</a>.
+    </p>
+    
+    <p>
+    This has little impact on the operation of Exim if you don't use it's
+    features, however it is a very common requirement in modern Exim
+    installations, and as such, is included for ease of installation. The
+    usefulness of this extension is also greatly increased by the presence of
+    the extra ACLs.
+    </p>
+
+
+    <h3>Manually patching the Exim distribution.</h3>
+
+    <p>
+    Download and extract the latest Exim tarball from <a
+    href="http://www.exim.org/">http://www.exim.org/</a>, and the accompanying
+    patch from <a href="http://botanicus.net/dw/">http://botanicus.net/dw/</a>:
+    </p>
+
+    <kbd>
+    $ cd /usr/src<br />
+    $ wget http://www.exim.org/ftp/exim4/exim-4.32.tar.bz2<br />
+    $ wget http://botanicus.net/exim-python/exim-4.32py1.patch<br />
+    $ tar jxvf exim-4.32.tar.bz2
+    </kbd>
+
+    <p>
+    Enter the Exim source directory, and apply the patch:
+    </p>
+
+    <kbd>
+    $ cd exim-4.32<br />
+    $ patch -p1 &lt; ../exim-4.32py1.patch
+    </kbd>
+
+
+    <h3>Configuring the Exim sources.</h3>
+
+    <p>
+    Follow the Exim installation procedure outlined in the specification:
+    <a href="http://www.exim.org/exim-html-4.30/doc/html/spec_4.html"
+    >http://www.exim.org/exim-html-4.30/doc/html/spec_4.html</a>.
+    </p>
+
+    <p>
+    In <code>Local/Makefile</code>, you will additionally need to specify the
+    <code>EXIM_PYTHON</code>, <code>PYTHON_CC</code>,
+    <code>PYTHON_CCOPTS</code>, and <code>PYTHON_LIBS</code> variables. The
+    defaults should suffice, although you may need to adjust the included paths
+    if you have installed Python to a non-standard location.
+    </p>
+
+
+    <h3>Additional configuration directives.</h3>
+
+    <p>
+    In order to enable the extension, you must tell it the name of a Python
+    source file to load and compile at startup. Any modules, packages,
+    functions, and classes that you wish to use should be defined in this file,
+    or imported into it using the Python <code>import</code> statement.
+    </p>
+
+
+    <h4>python_at_start</h4>
+
+    <p>
+    The boolean <code>python_at_start</code> parameter indicates to Exim
+    whether or not it should load the extension at startup. It defaults to
+    <code>false</code>, to help reduce daemon memory usage slightly. Setting it
+    to <code>true</code> will increase the performance of the server when
+    Python calls are made later on. This is recommended for production servers.
+    </p>
+
+
+    <h4>python_startup</h4>
+
+    <p>
+    The string <code>python_startup</code> parameter specifies the name of the
+    Python source file to load and compile at startup. This parameter must be
+    set to a valid (existing, and syntactically valid) source file pathname in
+    order for the extension to be used.
+    </p>
+
+
+    <h4>Example:</h4>
+
+    <kbd>
+    # Parse and load a Python module for use in ${python} expansions.<br />
+    python_at_start = true<Br />
+    python_startup = /etc/exim/exim.py
+    </kbd>
+</div>
+
+
+
+
+<a name="usage"></a>
+<h2>How do I use the extension?</h2>
+
+<div class="section">
+    <h3>How the extension loads and runs your code.</h3>
+
+
+    <h4>File loading.</h4>
+
+    <p>
+    At startup, the extension will attempt to read in the contents of the file
+    specified by the <code>python_startup</code> configuration parameter,
+    compile it, and execute it as a module.
+    </p>
+
+    <h4>Usage of "__name__".</h4>
+
+    <p>
+    When the extension executes your code, it sets the module-level variable
+    <code>__name__</code> to <code>__exim__</code>. The usage semantics of
+    <code>__name__</code> are aligned with how Python uses it.
+    </p>
+    
+    <p>
+    By testing <code>__name__</code>, it is possible (although impractical in
+    many cases) to write a single Python source file that will operate as a
+    standard Python module, an Exim-Python module, and as a command-line tool.
+    Here is an example:
+    </p>
+
+    <kbd>
+    if __name__ == '__main__':<br />
+        &nbsp;&nbsp;&nbsp; run_commandline()<br />
+    <br />
+    elif __name__ == '__exim__':<br />
+        &nbsp;&nbsp;&nbsp; init_exim_module()<br />
+    <br />
+    else:<br />
+        &nbsp;&nbsp;&nbsp; pass
+        # Running as a Python module, do nothing.
+    </kbd>
+
+
+
+    <h3>How Python functions and methods are called.</h3>
+
+    <p>
+    When the extension encounters a <code>${python {&lt;fn&gt;} ...}</code>
+    expansion, it resolves the name <code>&lt;fn&gt;</code>. In the module
+    loaded previously. <code>...</code> may be one or more string arguments
+    that will be passed to the Python function, encapsulated in braces.
+    </p>
+
+    <h4>Return values and exceptions.</h4>
+
+    <p>
+    Several rules are applied to the result of your Python function, and it is
+    very important you understand them. <strong>Note</strong>: it is an error
+    if your Python function does not return a value!
+    </p>
+
+    <ul>
+    <li>If the called function returns <code>None</code> (implicit default if
+        no <code>return</code> with value executed), then the expansion is
+        forced to fail.</li>
+
+    <li>If the called function generates an exception, the exception will be
+        printed on <code>sys.stderr</code>, a log will be made in the paniclog,
+        and the expansion will be forced to fail.</li>
+
+    <li>If the called function returns <code>True</code> or <code>False</code>
+        (the boolean singletons), these are converted to the strings
+        <code>true</code> and <code>false</code> respectively.</li>
+    </ul>
+
+
+
+
+    <h3>Loading and initialising module resources.</h3>
+
+    <p>
+    Exim is a rather complex piece of software, and the execution path it takes
+    can be quite confusing at times. For this reason, it is desirable to be as
+    careful as possible when initialising and using resources.
+    </p>
+
+
+    <h4>The problem.</h4>
+
+    <p>
+    Exim forks quite regularly, and much of it's operation happens inside a
+    subprocess. When Exim performs a fork, any objects existing in the Python
+    interpreter at the time of fork will now be duplicated.
+    </p>
+    
+    <p>
+    This can lead to dangerous and incorrect use of, for example, database
+    connections, which will now have essentially two clients connected to only
+    one client's connection.
+    </p>
+
+    <p>
+    The extension as yet does not provide any automatic means for handling
+    objects that should be destroyed or reinitialised at fork time, so it is up
+    to you to do this.
+    </p>
+
+    <!-- <p>
+    The resulting code often makes judicious use of global variables, that
+    while ugly, are the best solution to the problem.
+    </p> -->
+
+
+    <h4>A simple solution.</h4>
+
+    <p>
+    Here, our dangerous resource is created and destroyed every time the
+    function is entered. This avoids the problem in almost all cases.
+    </p>
+
+    <kbd>
+    def get_db():<br />
+    &nbsp; &nbsp; db = MySQL.connect(**mysql_connection_details)<br />
+    &nbsp; &nbsp; return db, db.cursor()<br />
+    <br />
+    <br />
+    def lookup_password(username):<br />
+    &nbsp; &nbsp; db, cursor = get_db()<br />
+    <br />
+    &nbsp; &nbsp; if not cursor.execute("""SELECT ..."""):<br />
+    &nbsp; &nbsp; &nbsp; &nbsp; return None # force failure.<br />
+    <br />
+    &nbsp; &nbsp; return cursor.fetchone()[0]
+    </kbd>
+</div>
+
+
+
+<a name="notes"></a>
+<h2>Things you should know before use.</h2>
+
+<div class="section">
+    <h3>Restrictions</h3>
+
+    <p>
+    Every feature of the Python environment is not available from within Exim.
+    Certain limitations are placed on your code to avoid destablizing the Exim
+    server process. Here they are:
+    </p>
+
+
+    <h4>Avoid the use of threads.</h4>
+
+    <p>
+    Or, do so at your own risk. There are many complications associated with
+    the use of threads, and you can almost certainly accomplish your goal
+    without using them.
+    </p>
+
+
+    <h4>Avoid signal manipulation.</h4>
+
+    <p>
+    At this time, it is currently unknown how Exim would deal with restarting
+    system calls in the case of a signal delivery handled by the extension. It
+    is recommended that you avoid all use of the <code>signal</code> module
+    until usage documentation appears in a future release of this extension.
+    </p>
+
+
+    <h3>Other usage notes.</h3>
+
+    <ul>
+    <li>
+        If your code opens any files, it is recommended that you use the
+        <code>fcntl.FD_CLOEXEC</code> flag on them, in order to enhance
+        security, and keep the files within their required scope.
+    </li>
+
+    <li>
+        If you are seeing failed string expansions, but no further traceback
+        information is being provided, you may want to reopen the
+        <code>sys.stderr</code> object in your module, directed to a file in
+        <code>/tmp</code>. A better solution to this is in the works.
+    </li>
+
+    <li>
+        If you instanciate a class, or wish to write directly to a function or method
+        or callable class deep inside a module hierarchy, you may do so. Example:
+
+        <kbd>
+        # Python code:<br />
+        import sys<br />
+        <br />
+        # Exim expansion:<br />
+        ${python {sys.stderr.write} {$sender_host_address}}
+        </kbd>
+    </li>
+    </ul>
+</div>
+
+
+
+<a name="examples"></a>
+<h2>Usage examples.</h2>
+
+
+<div class="section">
+    <h3>Deny connections from certain countries using GeoIP.</h3>
+
+    <p>
+    This example combines the extension with Exim's built-in access control
+    lists. Here, we prevent connections to the mail server unless they
+    originate a country that is specifically authorised to send e-mail to us.
+    This is an effective, if dangerous, anti-spam measure for English speakers.
+    </p>
+
+    <p>
+    It requires the GeoIP client library, a copy of the GeoIP database, and the
+    GeoIP Python bindings. See <a href="http://www.maxmind.com/app/python"
+    >http://www.maxmind.com/app/python</a>.
+    </p>
+
+
+    <h4>Python Module</h4>
+
+    <kbd>
+    import GeoIP<br />
+    <br />
+    gi = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)<br />
+    allowed_countries = [ 'UK', 'US', 'CA', 'EU', 'IE' ]<br />
+    <br />
+    <br />
+    def connect_denied(remote_addr)<br />
+    &nbsp; &nbsp; if not remote_addr: # Local connection.<br />
+    &nbsp; &nbsp; &nbsp; &nbsp; return False # Allow it.<br />
+    <br />
+    &nbsp; &nbsp; country = gi.country_code_by_addr(remote_addr)<br />
+    &nbsp; &nbsp; return country not in allowed_countries
+    </kbd>
+
+
+    <h4>Exim Configuration</h4>
+
+    <kbd>
+    # My "acl_smtp_connect" ACL:<br />
+    <br />
+    acl_check_connect:<br />
+    &nbsp; &nbsp; deny condition = ${python {connect_denied} {$sender_host_address}}<br />
+    &nbsp; &nbsp; &nbsp; &nbsp;
+        &nbsp;message &nbsp; = "Your country is not allowed to connect to this server."<br />
+    </kbd>
+
+</div>
+
+
+
+
+<a name="changes"></a>
+<h2>Changes between versions.</h2>
+
+
+<div class="section">
+    <h3>April 25th, 2004.</h3>
+
+    <ul>
+    <li>First public beta release.</li>
+    <li>Added HTML documentation.</li>
+    <li>Added <code>obj.subobj.subobj.callable</code> resolution.</li>
+    <li>Fixed silly reference counting bug in <code>python_resolve()</code>.</li>
+    </ul>
+
+
+    <h3>February 20th, 2004.</h3>
+
+    <ul>
+    <li>Initial public alpha release.</li>
+    </ul>
+
+</div>
+
+
+
+
+<a name="future"></a>
+<h2>Future considerations.</h2>
+
+
+<div class="section">
+    <h3>Needs fixed.</h3>
+
+    <ul>
+    <li>When running Exim in debug mode, for example, with 
+        <code>exim -d -bd</code>, pressing the interrupt key will not shut Exim
+        down. This is evidence that Python is still further damaging signals or
+        some other behaviour, and requires investigation.</li>
+
+    </ul>
+
+
+
+    <h3>Needs tested.</h3>
+
+    <ul>
+    <li>Verify that <code>save_signals()</code> and <code>load_signals()</code>
+        in <code>python.c</code> are working effectively.</li>
+
+    <li>Ensure that <code>PyOS_AfterFork()</code> is called only when
+        necessary.</li>
+
+    <li>Check the safety of <code>while ()</code> predicates in
+        <code>python.c:python_resolve()</code>.</li>
+
+    </ul>
+
+
+
+    <h3>Needs implemented.</h3>
+
+    <ul>
+    <li>Add memory checking to <code>python.c:call_python_cat()</code> in the
+        arg tuple build.</li>
+
+    <li>Add memory checking to <code>python.c:save_signals()</code>.
+
+    <li>Remove the requirement for <code>#undef HAVE_SETEUID</code> in
+        <code>python.c</code>. Find out if it is Exim or Python being
+        ignorant.</li>
+
+    <li>Add support for <code>${pythonkw {keywordlist} [{arg1} [{argn}
+        ..]]}</code> for calling objects that can accept keyword arguments.
+        keywordlist will be of the exim form <code>key=val key2=val2</code> and
+        so on.</li>
+
+    <li>Add support for converting Python dictionaries into Exim-style
+        <code>key=val</code> strings on return from a function.</li>
+
+    <li>Make Python traceback output configurable to syslog, file, standard
+        error, or Exim's paniclog.</li>
+
+    </ul>
+
+
+
+    <h3>The wishlist.</h3>
+
+    <ul>
+    <li>Add a standard way of registering objects that need reinitialised after
+        a fork. Some sort of
+        <code>
+            (&lt;parent&gt;,
+             &lt;object_name&gt;,
+             &lt;constructor&gt;,
+             &lt;constructor_args&gt;,
+             &lt;constructor_kwargs&gt;,
+             &lt;reinit_where&gt;)</code>
+        6-tuple?</li>
+
+    <li>Add support for modifying certain Exim variables at run-time, for hot
+        reconfiguration, and so fourth. This would require the ability to
+        safely trigger Python code at arbitrary locations in Exim. A
+        mammoth task, and a potentially involved implementation.</li>
+
+    <li>Make available a <code>python</code> router, transport, and
+        authenticator. This might be useful to some, for example, for
+        SQL-backed e-mail storage.</li>
+
+    <li>Add a general <code>exim</code> module, to allow certain internal Exim
+        functions be called from Python. This would also encapsulate the
+        run-time reconfiguration wishlist item.</li>
+</div>
+
+</body>
+</html>
diff -urN /usr/src/builds/exim-4.32/OS/Makefile-Base /usr/src/builds/exim-4.32py1/OS/Makefile-Base
--- /usr/src/builds/exim-4.32/OS/Makefile-Base	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/OS/Makefile-Base	2004-04-26 00:54:17.000000000 +0100
@@ -295,9 +295,12 @@
         store.o string.o tls.o tod.o transport.o tree.o verify.o \
         local_scan.o $(EXIM_PERL)
 
+OBJ_EXIM += $(EXIM_PYTHON)
+
 exim:   pcre/libpcre.a lookups/lookups.a auths/auths.a \
         routers/routers.a transports/transports.a \
-        $(OBJ_EXIM) version.c
+        $(OBJ_EXIM) version.c \
+        $(OBJ_PYTHON)
 	@echo " "
 	awk '{ print ($$1+1) }' cnumber.h > cnumber.temp
 	rm -f cnumber.h; mv cnumber.temp cnumber.h
@@ -308,7 +311,8 @@
 	  routers/routers.a transports/transports.a lookups/lookups.a \
 	  auths/auths.a \
 	  $(LIBRESOLV) $(LIBS) $(LIBS_EXIM) $(IPV6_LIBS) $(EXTRALIBS) \
-	  $(EXTRALIBS_EXIM) $(DBMLIB) $(LOOKUP_LIBS) $(PERL_LIBS) $(TLS_LIBS)
+	  $(EXTRALIBS_EXIM) $(DBMLIB) $(LOOKUP_LIBS) $(PERL_LIBS) $(TLS_LIBS) \
+	  $(PYTHON_LIBS)
 	@if [ x"$(STRIP_COMMAND)" != x"" ]; then \
 	  echo $(STRIP_COMMAND) exim; \
 	  $(STRIP_COMMAND) exim; \
@@ -445,6 +449,11 @@
 perl.o:          $(HDRS) perl.c
 	$(PERL_CC) $(PERL_CCOPTS) $(INCLUDE) -c perl.c
 
+# Compile instructions for python.o for when EXIM_PYTHON is set
+
+python.o:        $(HDRS) python.c
+	$(PYTHON_CC) $(PYTHON_CCOPTS) $(INCLUDE) -c python.c
+
 # Compile instructions for the database utility modules
 
 exim_dumpdb.o:   $(HDRS) exim_dbutil.c
diff -urN /usr/src/builds/exim-4.32/OS/Makefile-CYGWIN /usr/src/builds/exim-4.32py1/OS/Makefile-CYGWIN
--- /usr/src/builds/exim-4.32/OS/Makefile-CYGWIN	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/OS/Makefile-CYGWIN	2004-04-26 00:48:00.000000000 +0100
@@ -82,6 +82,7 @@
 ZCAT_COMMAND=/usr/bin/zcat
 
 # EXIM_PERL=perl.o
+# EXIM_PYTHON=python.o
 
 # Comment the two lines below if you do not have PAM, e.g. from
 # ftp://ftp.uni-erlangen.de/pub/pc/gnuwin32/cygwin/porters/Humblet_Pierre_A
diff -urN /usr/src/builds/exim-4.32/scripts/MakeLinks /usr/src/builds/exim-4.32py1/scripts/MakeLinks
--- /usr/src/builds/exim-4.32/scripts/MakeLinks	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/scripts/MakeLinks	2004-04-26 00:54:17.000000000 +0100
@@ -212,6 +212,7 @@
 ln -s ../src/moan.c            moan.c
 ln -s ../src/parse.c           parse.c
 ln -s ../src/perl.c            perl.c
+ln -s ../src/python.c          python.c
 ln -s ../src/queue.c           queue.c
 ln -s ../src/rda.c             rda.c
 ln -s ../src/readconf.c        readconf.c
diff -urN /usr/src/builds/exim-4.32/src/child.c /usr/src/builds/exim-4.32py1/src/child.c
--- /usr/src/builds/exim-4.32/src/child.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/child.c	2004-04-26 00:48:00.000000000 +0100
@@ -198,6 +198,10 @@
 
 if (pid == 0)
   {
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork(); /* Update internal python state. */
+  #endif
+
   force_fd(pfd[pipe_read], 0);
   close(pfd[pipe_write]);
   if (debug_fd > 0) force_fd(debug_fd, 2);
diff -urN /usr/src/builds/exim-4.32/src/config.h.defaults /usr/src/builds/exim-4.32py1/src/config.h.defaults
--- /usr/src/builds/exim-4.32/src/config.h.defaults	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/config.h.defaults	2004-04-26 00:48:00.000000000 +0100
@@ -39,6 +39,7 @@
 #define EXIMDB_MODE                0640
 
 #define EXIM_PERL
+#define EXIM_PYTHON
 
 /* Both uid and gid are triggered by this */
 #define EXIM_UID
diff -urN /usr/src/builds/exim-4.32/src/daemon.c /usr/src/builds/exim-4.32py1/src/daemon.c
--- /usr/src/builds/exim-4.32/src/daemon.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/daemon.c	2004-04-26 00:48:00.000000000 +0100
@@ -340,6 +340,10 @@
   struct sigaction act;
   #endif
 
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork();
+  #endif
+
   /* Get the local interface address into some permanent store, and also set
   the port. */
 
@@ -530,6 +534,10 @@
 
       if ((dpid = fork()) == 0)
         {
+        #ifdef EXIM_PYTHON
+        PyOS_AfterFork();
+        #endif
+
         fclose(smtp_in);
         fclose(smtp_out);
 
@@ -1071,6 +1079,10 @@
     if (pid > 0) exit(EXIT_SUCCESS);      /* in parent process, just exit */
     (void)setsid();                       /* release controlling terminal */
     }
+
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork(); /* is this necessary? when does python get init? -dw */
+  #endif
   }
 
 /* We are now in the disconnected, daemon process (unless debugging). Set up
@@ -1411,6 +1423,10 @@
       if ((pid = fork()) == 0)
         {
         int sk;
+        #ifdef EXIM_PYTHON
+        PyOS_AfterFork(); /* Update python internal state. */
+        #endif
+
         DEBUG(D_any) debug_printf("Starting queue-runner: pid %d\n",
           (int)getpid());
 
diff -urN /usr/src/builds/exim-4.32/src/deliver.c /usr/src/builds/exim-4.32py1/src/deliver.c
--- /usr/src/builds/exim-4.32/src/deliver.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/deliver.c	2004-04-26 00:54:17.000000000 +0100
@@ -1594,6 +1594,10 @@
   {
   BOOL replicate = TRUE;
 
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork(); /* Update internal python state. */
+  #endif
+
   /* Prevent core dumps, as we don't want them in users' home directories.
   HP-UX doesn't have RLIMIT_CORE; I don't know how to do this in that
   system. Some experimental/developing systems (e.g. GNU/Hurd) may define
@@ -3621,6 +3625,10 @@
     int fd = pfd[pipe_write];
     host_item *h;
 
+    #ifdef EXIM_PYTHON
+    PyOS_AfterFork(); /* Update internal python state. */
+    #endif
+
     /* There are weird circumstances in which logging is disabled */
 
     disable_logging = tp->disable_logging;
diff -urN /usr/src/builds/exim-4.32/src/EDITME /usr/src/builds/exim-4.32py1/src/EDITME
--- /usr/src/builds/exim-4.32/src/EDITME	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/EDITME	2004-04-26 00:48:00.000000000 +0100
@@ -603,6 +603,12 @@
 
 
 #------------------------------------------------------------------------------
+# Support Python string expansion. Requires python 2.2+
+
+# EXIM_PYTHON=python.o
+
+
+#------------------------------------------------------------------------------
 # Exim has support for PAM (Pluggable Authentication Modules), a facility
 # which is available in the latest releases of Solaris and in some GNU/Linux
 # distributions (see http://ftp.kernel.org/pub/linux/libs/pam/). The Exim
@@ -913,6 +919,15 @@
 
 
 #------------------------------------------------------------------------------
+# Compiler, compiler options, and libraries settings for building the Python
+# interface.
+
+# PYTHON_CC=cc
+# PYTHON_CCOPTS=-I/usr/include/python2.3
+# PYTHON_LIBS=-lpython2.3
+
+
+#------------------------------------------------------------------------------
 # Identifying the daemon: When an Exim daemon starts up, it writes its pid
 # (process id) to a file so that it can easily be identified. The path of the
 # file can be specified here. Some installations may want something like this:
diff -urN /usr/src/builds/exim-4.32/src/exim.c /usr/src/builds/exim-4.32py1/src/exim.c
--- /usr/src/builds/exim-4.32/src/exim.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/exim.c	2004-04-26 00:54:17.000000000 +0100
@@ -800,6 +800,9 @@
 #ifdef EXIM_PERL
   fprintf(f, " Perl");
 #endif
+#ifdef EXIM_PYTHON
+  fprintf(f, " Exim-Python");
+#endif
 #ifdef USE_TCP_WRAPPERS
   fprintf(f, " TCPwrappers");
 #endif
@@ -973,6 +976,9 @@
 #ifdef EXIM_PERL
 int  perl_start_option = 0;
 #endif
+#ifdef EXIM_PYTHON
+int  python_start_option = 0;
+#endif
 int  recipients_arg = argc;
 int  sender_address_domain = 0;
 int  test_retry_arg = -1;
@@ -2274,6 +2280,18 @@
     break;
 
 
+    /* -Ps: force python startup; -Pd force delayed python startup */
+
+    #ifdef EXIM_PYTHON
+    case 'P':
+    if (*argrest == 's' && argrest[1] == 0) python_start_option = 1;
+    else
+      if (*argrest == 'd' && argrest[1] == 0) python_start_option = -1;
+    else badarg = TRUE;
+    break;
+    #endif
+
+
     case 'q':
     receiving_message = FALSE;
 
@@ -2926,6 +2944,25 @@
   }
 #endif /* EXIM_PERL */
 
+/* Start up python if support is configured and there is a python_startup option,
+and the configuration or command line specifies starting. */
+
+#ifdef EXIM_PYTHON
+if (python_start_option != 0)
+  opt_python_at_start = (python_start_option > 0);
+if (opt_python_at_start && opt_python_startup != NULL)
+  {
+  uschar *errstr;
+  errstr = init_python(opt_python_startup);
+  if (errstr != NULL)
+    {
+    fprintf(stderr, "exim: python startup error: %s\n", errstr);
+    return EXIT_FAILURE;
+    }
+  opt_python_started = TRUE;
+  }
+#endif /* EXIM_PYTHON */
+
 /* Log the arguments of the call if the configuration file said so. This is
 a debugging feature for finding out what arguments certain MUAs actually use.
 Don't attempt it if logging is disabled, or if listing variables or if
@@ -4294,6 +4331,10 @@
     pid_t pid;
     if ((pid = fork()) == 0)
       {
+      #ifdef EXIM_PYTHON
+      PyOS_AfterFork(); /* Update internal python state. */
+      #endif
+
       close_unwanted();      /* Close unwanted file descriptors and TLS */
 
       /* Re-exec Exim if we need to regain privilege */
diff -urN /usr/src/builds/exim-4.32/src/expand.c /usr/src/builds/exim-4.32py1/src/expand.c
--- /usr/src/builds/exim-4.32/src/expand.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/expand.c	2004-04-26 00:54:17.000000000 +0100
@@ -56,6 +56,9 @@
   #ifdef EXIM_PERL
     US"perl",
   #endif
+  #ifdef EXIM_PYTHON
+  US"python",
+  #endif
   US"readfile",
   US"readsocket",
   US"run",
@@ -74,6 +77,9 @@
   #ifdef EXIM_PERL
     EITEM_PERL,
   #endif
+  #ifdef EXIM_PYTHON
+  EITEM_PYTHON,
+  #endif
   EITEM_READFILE,
   EITEM_READSOCK,
   EITEM_RUN,
@@ -2858,6 +2864,93 @@
       }
     #endif /* EXIM_PERL */
 
+    /* If Python support is configured, handle calling embedded python subroutines,
+    unless locked out at this time. Syntax is ${python{sub}} or ${python{sub}{arg}}
+    or ${python{sub}{arg1}{arg2}} or up to a maximum of EXIM_PYTHON_MAX_ARGS
+    arguments (defined below). */
+
+    #ifdef EXIM_PYTHON
+    #define EXIM_PYTHON_MAX_ARGS 8
+
+    case EITEM_PYTHON:
+      {
+      uschar *sub_arg[EXIM_PYTHON_MAX_ARGS + 2];
+      uschar *new_yield;
+
+      if ((expand_forbid & RDO_PYTHON) != 0)
+        {
+        expand_string_message = US"Python calls are not permitted";
+        goto EXPAND_FAILED;
+        }
+
+      switch(read_subs(sub_arg, EXIM_PYTHON_MAX_ARGS + 1, 1, &s, skipping, TRUE,
+           US"python"))
+        {
+        case 1: goto EXPAND_FAILED_CURLY;
+        case 2:
+        case 3: goto EXPAND_FAILED;
+        }
+
+      /* If skipping, we don't actually do anything */
+
+      if (skipping) continue;
+
+      /* Start the interpreter if necessary */
+
+      if (!opt_python_started)
+        {
+        uschar *initerror;
+        if (opt_python_startup == NULL)
+          {
+          expand_string_message = US"A setting of python_startup is needed when "
+            "using the Python interpreter";
+          goto EXPAND_FAILED;
+          }
+        DEBUG(D_any) debug_printf("Starting Python interpreter\n");
+        initerror = init_python(opt_python_startup);
+        if (initerror != NULL)
+          {
+          expand_string_message =
+            string_sprintf("error in python_startup code: %s\n", initerror);
+          goto EXPAND_FAILED;
+          }
+        opt_python_started = TRUE;
+        }
+
+      /* Call the function */
+
+      sub_arg[EXIM_PYTHON_MAX_ARGS + 1] = NULL;
+      new_yield = call_python_cat(yield, &size, &ptr, &expand_string_message,
+        sub_arg[0], sub_arg + 1);
+
+      /* NULL yield indicates failure; if the message pointer has been set to
+      NULL, the yield was undef, indicating a forced failure. Otherwise the
+      message will indicate some kind of Python error. */
+
+      if (new_yield == NULL)
+        {
+        if (expand_string_message == NULL)
+          {
+          expand_string_message =
+            string_sprintf("Python subroutine \"%s\" returned None to force "
+              "failure", sub_arg[0]);
+          expand_string_forcedfail = TRUE;
+          }
+        goto EXPAND_FAILED;
+        }
+
+      /* Yield succeeded. Ensure forcedfail is unset, just in case it got
+      set during a callback from Python. (??? -dw) */
+
+      expand_string_forcedfail = FALSE;
+      yield = new_yield;
+      continue;
+      }
+    #endif /* EXIM_PYTHON */
+
+
+
+
     /* Handle "readfile" to insert an entire file */
 
     case EITEM_READFILE:
diff -urN /usr/src/builds/exim-4.32/src/functions.h /usr/src/builds/exim-4.32py1/src/functions.h
--- /usr/src/builds/exim-4.32/src/functions.h	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/functions.h	2004-04-26 00:54:17.000000000 +0100
@@ -19,6 +19,13 @@
 extern uschar *init_perl(uschar *);
 #endif
 
+#ifdef EXIM_PYTHON
+extern uschar *call_python_cat(uschar *, int *, int *, uschar **, uschar *,
+                 uschar **);
+extern void    cleanup_python(void);
+extern uschar *init_python(uschar *);
+#endif
+
 
 #ifdef SUPPORT_TLS
 extern int     tls_client_start(int, host_item *, address_item *, uschar *,
diff -urN /usr/src/builds/exim-4.32/src/globals.c /usr/src/builds/exim-4.32py1/src/globals.c
--- /usr/src/builds/exim-4.32/src/globals.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/globals.c	2004-04-26 00:54:17.000000000 +0100
@@ -60,6 +60,12 @@
 BOOL    opt_perl_started       = FALSE;
 #endif
 
+#ifdef EXIM_PYTHON
+uschar *opt_python_startup     = NULL;
+BOOL    opt_python_at_start    = FALSE;
+BOOL    opt_python_started     = FALSE;
+#endif
+
 #ifdef LOOKUP_IBASE
 uschar *ibase_servers          = NULL;
 #endif
diff -urN /usr/src/builds/exim-4.32/src/globals.h /usr/src/builds/exim-4.32py1/src/globals.h
--- /usr/src/builds/exim-4.32/src/globals.h	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/globals.h	2004-04-26 00:54:17.000000000 +0100
@@ -24,6 +24,12 @@
 extern BOOL    opt_perl_started;       /* Set once interpreter started */
 #endif
 
+#ifdef EXIM_PYTHON
+extern uschar *opt_python_startup;       /* Startup env for python */
+extern BOOL    opt_python_at_start;      /* Start python at boot */
+extern BOOL    opt_python_started;       /* Set once interpreter started */
+#endif
+
 #ifdef LOOKUP_IBASE
 extern uschar *ibase_servers;
 #endif
diff -urN /usr/src/builds/exim-4.32/src/log.c /usr/src/builds/exim-4.32py1/src/log.c
--- /usr/src/builds/exim-4.32/src/log.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/log.c	2004-04-26 00:48:00.000000000 +0100
@@ -344,6 +344,10 @@
 
   if (pid == 0)
     {
+    #ifdef EXIM_PYTHON
+    PyOS_AfterFork(); /* Update internal python state. */
+    #endif
+
     (void)setgid(exim_gid);
     (void)setuid(exim_uid);
     _exit((create_log(buffer) < 0)? 1 : 0);
diff -urN /usr/src/builds/exim-4.32/src/macros.h /usr/src/builds/exim-4.32py1/src/macros.h
--- /usr/src/builds/exim-4.32/src/macros.h	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/macros.h	2004-04-26 00:54:17.000000000 +0100
@@ -466,11 +466,12 @@
 #define RDO_RUN        0x00004000  /* Forbid "run" in expansion in filter */
 #define RDO_REALLOG    0x00008000  /* Really do log (not testing/verifying) */
 #define RDO_REWRITE    0x00010000  /* Rewrite generated addresses */
+#define RDO_PYTHON     0x00020000  /* Forbid "python" in expansion in filter */
 
 /* This is the set that apply to expansions in filters */
 
 #define RDO_FILTER_EXPANSIONS \
-  (RDO_EXISTS|RDO_LOOKUP|RDO_PERL|RDO_READFILE|RDO_READSOCK|RDO_RUN)
+  (RDO_EXISTS|RDO_LOOKUP|RDO_PERL|RDO_PYTHON||RDO_READFILE|RDO_READSOCK|RDO_RUN)
 
 /* As well as the RDO bits themselves, we need the bit numbers in order to
 access (most of) the individual bits as separate options. This could be
@@ -479,7 +480,7 @@
 enum { RDON_BLACKHOLE, RDON_DEFER, RDON_EACCES, RDON_ENOTDIR, RDON_EXISTS,
   RDON_FAIL, RDON_FILTER, RDON_FREEZE, RDON_INCLUDE, RDON_LOG, RDON_LOOKUP,
   RDON_PERL, RDON_READFILE, RDON_READSOCK, RDON_RUN, RDON_REALLOG,
-  RDON_REWRITE };
+  RDON_REWRITE, RDON_PYTHON };
 
 /* Results of filter or forward file processing. Some are only from a filter;
 some are only from a forward file. */
diff -urN /usr/src/builds/exim-4.32/src/python.c /usr/src/builds/exim-4.32py1/src/python.c
--- /usr/src/builds/exim-4.32/src/python.c	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/python.c	2004-04-26 00:48:00.000000000 +0100
@@ -0,0 +1,438 @@
+/*
+	Exim-Python v0.1, 2004-02-19.
+	This module implements a bridge between Python 2.2+ and the Exim MTA.
+
+	I, the author, hereby waive all copyright held on this code, and declare it
+	to be the property of the public domain. This code may be used in whole or
+	in part for any purpose, without permission.
+
+	Author: David M. Wilson <dw-exim-python.c@botanicus.net>.
+*/
+
+
+#include "Python.h"
+#undef HAVE_SETEUID
+#include "exim.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <signal.h>
+
+
+
+
+/* The user's loaded Python module. */
+static PyObject *exim_module;
+
+/* Message buffer. I can't see anywhere else to store them. */
+static uschar python_error[512];
+
+
+
+
+/*
+	As with vsnprintf, but ensure NULL termination.
+*/
+
+static int
+safe_vsnprintf(uschar *str, size_t size, const char *fmt, va_list ap)
+{
+	int retval;
+	retval = vsnprintf(str, size, fmt, ap);
+	str[size-1] = 0;
+	return retval;
+}
+
+
+
+
+/*
+	As with snprintf, but ensure NULL termination.
+*/
+
+static int
+safe_snprintf(uschar *str, size_t size, const char *fmt, ...)
+{
+	va_list ap;
+	int retval;
+
+	va_start(ap, fmt);
+	retval = safe_vsnprintf(str, size, fmt, ap);
+	va_end(ap);
+
+	return retval;
+}
+
+
+
+
+/*
+	Write an error message to the global error buffer. Prepend an identifer.
+	If traceback is nonzero, output a traceback to stderr. Return the length of
+	the error message.
+*/
+
+static int
+error_set(int traceback, const char *fmt, ...)
+{
+	va_list ap;
+	int len;
+
+	va_start(ap, fmt);
+	strcpy(python_error, "Python error: ");
+	len = safe_vsnprintf(python_error, sizeof python_error - 14, fmt, ap);
+
+	if (len < (sizeof python_error - 1))
+		strcat(python_error, "\n");
+
+	va_end(ap);
+
+	if (traceback)
+		PyErr_Print();
+
+	return len + 14;
+}
+
+
+
+
+/*
+	Save the states of signals known to be used by Exim. Return a value
+	suitable for passing to save_signals().
+*/
+
+static struct sigaction *
+save_signals(void)
+{
+	struct sigaction *signals;
+	int i;
+
+	signals = PyMem_Malloc(sizeof(struct sigaction) * 64);
+
+	for (i = 1; i != 64; i ++)
+		sigaction(i, NULL,  &signals[i-1]);
+
+	return signals;
+}
+
+
+
+
+/*
+	Perform the inverse of save_signals.
+*/
+
+static void
+load_signals(struct sigaction *signals)
+{
+	int i;
+
+	for (i = 1; i != 64; i ++)
+		sigaction(i, &signals[i-1], NULL);
+
+	PyMem_Free(signals);
+}
+
+
+
+
+/*
+	Return the contents of the file named in <filename> as a Python-allocated
+	string. Return NULL on failure, setting errno.
+*/
+
+static uschar *
+file_as_string(const char *filename, off_t *size)
+{
+	struct stat st;
+	uschar *output;
+	FILE *fp;
+
+
+	if (stat(filename, &st) == -1)
+		return NULL;
+
+	if ((fp = fopen(filename, "r")) == NULL)
+		return NULL;
+
+	if ((output = PyMem_Malloc(st.st_size + 1)) == NULL)
+	{
+		fclose(fp);
+		return NULL;
+	}
+
+	if (fread(output, 1, st.st_size, fp) != st.st_size)
+	{
+		fclose(fp);
+		PyMem_Free(output);
+		return NULL;
+	}
+
+
+	output[st.st_size] = 0;
+
+	if (size)
+		*size = st.st_size;
+
+	return output;
+}
+
+
+
+/*
+	Initialise the Exim-Python environment, loading the user module specified in
+	<module_filename>. Return NULL on success, or a pointer to an error message
+	on failure.
+*/
+
+uschar *
+init_python(uschar *module_filename)
+{
+	PyObject *compiled_module;
+	uschar *module_buf;
+	struct sigaction *signals;
+	int retval;
+
+	if ((module_buf = file_as_string(module_filename, NULL)) == NULL)
+	{
+		error_set(0, "could not read \"%s\": %s", module_filename, strerror(errno));
+		return python_error;
+	}
+
+
+	/* Load Python, preserving signal handlers used by Exim. */
+	signals = save_signals();
+	Py_Initialize();
+	load_signals(signals);
+
+
+	compiled_module = Py_CompileString(module_buf, module_filename, Py_file_input);
+	PyMem_Free(module_buf);
+
+	if (compiled_module == NULL)
+	{
+		error_set(1, "failed to compile \"%s\", see traceback.", module_filename);
+		return python_error;
+	}
+
+
+	exim_module = PyImport_ExecCodeModule("__exim__", compiled_module);
+	Py_DECREF(compiled_module);
+
+	if (exim_module == NULL)
+	{
+		error_set(1, "failed to execute \"%s\", see traceback.", module_filename);
+		return python_error;
+	}
+
+	DEBUG(D_any) debug_printf("Exim-Python initialised from \"%s\".\n", module_filename);
+	return NULL;
+}
+
+
+
+
+/*
+	Shut down the Exim-Python environment.
+*/
+
+void
+cleanup_python(void)
+{
+	fprintf(stderr, "[in cleanup_python]\n");
+
+	if (! Py_IsInitialized())
+		return;
+
+	Py_DECREF(exim_module);
+	Py_Finalize();
+}
+
+
+
+
+/*
+	Given string <reference> of the form "a.b.c.d", resolve d by calling
+	PyObject_GetAttr starting from <root> in a cyclic manner. Return new
+	reference to d on success. Return NULL and set an exception on failure.
+*/
+
+static PyObject *
+python_resolve(PyObject *root, const uschar *reference)
+{
+	uschar *attr_buf, *pos, *split;
+	PyObject *last;
+	int length;
+
+	length = strlen(reference) + 1;
+	attr_buf = PyMem_Malloc(length);
+
+	if (attr_buf == NULL)
+	{
+		PyErr_SetString(PyExc_RuntimeError, "out of memory.");
+		return NULL;
+	}
+
+	Py_INCREF(root);
+	strcpy(attr_buf, reference);
+	pos = attr_buf;
+
+	while (root != NULL && (pos < (attr_buf + length)))
+	{
+		split = strchr(pos, '.');
+
+		if (split != NULL)
+			*split = 0;
+
+		last = root;
+		root = PyObject_GetAttrString(last, pos);
+		Py_DECREF(last);
+
+		if (split == NULL)
+			break;
+
+		pos = split+1;
+	}
+
+
+	PyMem_Free(attr_buf);
+	return root;
+}
+
+
+
+
+/*
+	Call a Python object, returning it's result as a string. If the object returns 
+*/
+
+uschar *
+call_python_cat(uschar *yield, int *sizep, int *ptrp, uschar **errstrp,
+	uschar *name, uschar **arg)
+{
+	PyObject *callable, *py_args, *result, *str_rep;
+	uschar **org_arg, *retval, *py_str;
+	int argc, i;
+
+	retval = NULL;
+
+
+	/* Can we continue? */
+
+	if (! Py_IsInitialized())
+	{
+		*errstrp = "the Python interpreter has not been initialised.";
+		return NULL;
+	}
+
+
+	/* Does the function exist in the Python environment? */
+
+	callable = python_resolve(exim_module, name);
+
+	if (callable == NULL)
+	{
+		error_set(1, "${python {%s} ..} could not be found, see traceback.",
+			name);
+
+		*errstrp = python_error;
+		return NULL;
+	}
+
+
+	/* Find out how large an argument tuple we need.*/
+
+	org_arg = arg;
+
+	for (argc = 0; *arg ++;)
+		argc++;
+
+	arg = org_arg;
+
+
+	/* Build the argument tuple. */
+
+	py_args = PyTuple_New(argc);
+
+	for (i = 0; i != argc; i ++)
+		PyTuple_SET_ITEM(py_args, i, PyString_FromString(*arg++));
+
+
+	/* Call the function. */
+
+	py_str = NULL;
+	result = PyObject_Call(callable, py_args, NULL);
+
+	if (result == NULL)
+	{
+		error_set(1, "${python {%s} ..} failed, see traceback.", name);
+		*errstrp = python_error;
+		goto call_python_cat_out;
+	}
+
+
+	/*
+		Special-case True and False to lowercase representation. None fails the
+		expansion.
+	*/
+
+	if (result == Py_None)
+	{
+		DEBUG(D_any) debug_printf(
+			"${python {%s} ..} returned None, expansion failed.\n",
+			name
+		);
+
+		*errstrp = NULL;
+		retval = NULL;
+		goto call_python_cat_out;
+	}
+
+
+	if (result == Py_True)
+	{
+		retval = string_cat(yield, sizep, ptrp, "true", 5);
+		goto call_python_cat_out;
+	}
+
+
+	if (result == Py_False)
+	{
+		retval = string_cat(yield, sizep, ptrp, "false", 5);
+		goto call_python_cat_out;
+	}
+
+
+
+	/* Otherwise, try to convert the result to a string. */
+
+	str_rep = PyObject_Str(result);
+
+	if (str_rep == NULL)
+	{
+		error_set(1, "${python {%s} ..} was not converted, see traceback.",
+			name);
+		*errstrp = python_error;
+		goto call_python_cat_out;
+	}
+
+
+	/* Save the result to the output buffer. */
+
+	py_str = PyString_AS_STRING(str_rep);
+	retval = string_cat(yield, sizep, ptrp, py_str, PyString_Size(str_rep));
+	Py_DECREF(str_rep);
+
+
+call_python_cat_out:
+	Py_DECREF(py_args);
+	Py_DECREF(callable);
+	Py_DECREF(result);
+
+	return retval;
+}
diff -urN /usr/src/builds/exim-4.32/src/queue.c /usr/src/builds/exim-4.32py1/src/queue.c
--- /usr/src/builds/exim-4.32/src/queue.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/queue.c	2004-04-26 00:48:00.000000000 +0100
@@ -612,6 +612,10 @@
     f->text[SPOOL_NAME_LENGTH-2] = 0;
     if ((pid = fork()) == 0)
       {
+      #ifdef EXIM_PYTHON
+      PyOS_AfterFork(); /* Update internal python state. */
+      #endif
+
       (void)close(pfd[pipe_read]);
       _exit(deliver_message(f->text, force_delivery, FALSE));
       }
diff -urN /usr/src/builds/exim-4.32/src/rda.c /usr/src/builds/exim-4.32py1/src/rda.c
--- /usr/src/builds/exim-4.32/src/rda.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/rda.c	2004-04-26 00:48:00.000000000 +0100
@@ -584,6 +584,10 @@
   {
   header_line *waslast = header_last;   /* Save last header */
 
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork(); /* Update internal python state. */
+  #endif
+
   fd = pfd[pipe_write];
   close(pfd[pipe_read]);
   exim_setugid(ugid->uid, ugid->gid, FALSE, rname);
diff -urN /usr/src/builds/exim-4.32/src/readconf.c /usr/src/builds/exim-4.32py1/src/readconf.c
--- /usr/src/builds/exim-4.32/src/readconf.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/readconf.c	2004-04-26 00:54:17.000000000 +0100
@@ -261,6 +261,10 @@
   { "print_topbitchars",        opt_bool,        &print_topbitchars },
   { "process_log_path",         opt_stringptr,   &process_log_path },
   { "prod_requires_admin",      opt_bool,        &prod_requires_admin },
+#ifdef EXIM_PYTHON
+  { "python_at_start",          opt_bool,        &opt_python_at_start },
+  { "python_startup",           opt_stringptr,   &opt_python_startup },
+#endif
   { "qualify_domain",           opt_stringptr,   &qualify_domain_sender },
   { "qualify_recipient",        opt_stringptr,   &qualify_domain_recipient },
   { "queue_domains",            opt_stringptr,   &queue_domains },
diff -urN /usr/src/builds/exim-4.32/src/routers/redirect.c /usr/src/builds/exim-4.32py1/src/routers/redirect.c
--- /usr/src/builds/exim-4.32/src/routers/redirect.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/routers/redirect.c	2004-04-26 00:48:00.000000000 +0100
@@ -51,6 +51,10 @@
   { "forbid_filter_perl", opt_bit | (RDON_PERL << 16),
       (void *)offsetof(redirect_router_options_block, bit_options) },
   #endif
+  #ifdef EXIM_PYTHON
+  { "forbid_filter_python", opt_bit | (RDON_PYTHON << 16),
+      (void *)offsetof(redirect_router_options_block, bit_options) },
+  #endif
   { "forbid_filter_readfile", opt_bit | (RDON_READFILE << 16),
       (void *)offsetof(redirect_router_options_block, bit_options) },
   { "forbid_filter_readsocket", opt_bit | (RDON_READSOCK << 16),
diff -urN /usr/src/builds/exim-4.32/src/smtp_in.c /usr/src/builds/exim-4.32py1/src/smtp_in.c
--- /usr/src/builds/exim-4.32/src/smtp_in.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/smtp_in.c	2004-04-26 00:54:17.000000000 +0100
@@ -3359,6 +3359,10 @@
 
     if ((pid = fork()) == 0)
       {
+      #ifdef EXIM_PYTHON
+      PyOS_AfterFork(); /* Update internal python state. */
+      #endif
+
       smtp_input = FALSE;    /* This process is not associated with the */
       fclose(smtp_in);       /* SMTP call any more. */
       fclose(smtp_out);
@@ -3370,6 +3374,10 @@
 
       if (!smtp_etrn_serialize || (pid = fork()) == 0)
         {
+        #ifdef EXIM_PYTHON
+        PyOS_AfterFork(); /* Update internal python state. */
+        #endif
+
         DEBUG(D_exec) debug_print_argv(argv);
         exim_nullstd();                   /* Ensure std{in,out,err} exist */
         execv(CS argv[0], (char *const *)argv);
diff -urN /usr/src/builds/exim-4.32/src/transport.c /usr/src/builds/exim-4.32py1/src/transport.c
--- /usr/src/builds/exim-4.32/src/transport.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/transport.c	2004-04-26 00:48:00.000000000 +0100
@@ -985,6 +985,11 @@
 if ((write_pid = fork()) == 0)
   {
   BOOL rc;
+
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork(); /* Update internal python state. */
+  #endif
+
   close(fd_read);
   close(pfd[pipe_read]);
   nl_check_length = nl_escape_length = 0;
diff -urN /usr/src/builds/exim-4.32/src/transports/pipe.c /usr/src/builds/exim-4.32py1/src/transports/pipe.c
--- /usr/src/builds/exim-4.32/src/transports/pipe.c	2004-04-15 09:27:01.000000000 +0100
+++ /usr/src/builds/exim-4.32py1/src/transports/pipe.c	2004-04-26 00:48:00.000000000 +0100
@@ -649,6 +649,11 @@
 if (outpid == 0)
   {
   int count = 0;
+
+  #ifdef EXIM_PYTHON
+  PyOS_AfterFork();
+  #endif
+
   close(fd_in);
   set_process_info("reading output from |%s", cmd);
   while ((rc = read(fd_out, big_buffer, big_buffer_size)) > 0)
